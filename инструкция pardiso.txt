pardiso - Вычисляет решение набора разреженных линейных уравнений с одной или несколькими правыми частями.

Вызов функции:
void pardiso(...)

Параметры функции: 
_MKL_DSS_HANDLE_T pt - массив(64)
Дескриптор внутренней структуры данных. Записи должны быть обнулены до первого вызова pardiso. Уникальный для факторизации.
!!!После первого вызова paraiso не изменяйте pt напрямую, так как это может привести к серьезной утечке памяти

const MKL_INT *maxfct - 1
Максимальное количество факторов с идентичной структурой разреженности, которые должны храниться в памяти одновременно. В большинстве приложений это значение равно 1. Во внутреннем управлении структурой данных решателя можно одновременно хранить несколько различных факторизаций с одной и той же ненулевой структурой.

paradiso может обрабатывать несколько матриц с идентичным шаблоном разреженности матриц и одновременно сохранять коэффициенты этих матриц. Матрицы с другой структурой разреженности могут храниться в памяти с разными указателями адресов памяти pt.

const MKL_INT *mnum - 1
Указывает фактическую матрицу для фазы решения. С помощью этого скаляра вы можете определить, какую матрицу разложить на множители. Значение должно быть: 1 <= mnum <= maxfct. В большинстве приложений это значение равно 1

const MKL_INT *mtype -
Определяет тип матрицы, который влияет на метод поворота. Решатель intel one API PARDISO поддерживает следующие матрицы:

1 - вещественная структурно симметричная
2 - вещественная симметричная положительно определенная
-2 - вещественная симметричная неопределенная
3 - комплексная структурно-симметричная
4 - комплексная эрмитова положительно определенная
-4 - комплексная эрмитова неопределенная
6 - комплексная симметричная
11 - вещественная несимметричная 
13 - комплексная несимметричная
 
const MKL_INT *phase -
Управляет выполнением решателя. Обычно это двух- или трехзначное целое число. Первая цифра указывает на начальную фазу выполнения, а вторая цифра указывает на конечную фазу. PARADISO имеет следующие этапы исполнения:

Phase 1: Анализ уменьшения заполнения и символьная факторизация
Phase 2: Численная факторизация
Phase 3: Прямое и обратное решение, включая необязательное итеративное уточнение
Эту фазу можно разделить на две или три отдельные замены: вперед, назад и по диагонали

Фаза освобождения памяти (phase=0 или phase=-1)
Если предыдущий вызов подпрограммы содержал вычисленную информацию из предыдущих фаз, выполнение может начаться на любой фазе. Параметр phase может иметь следующие значения:

11 - Анализ
12 - Анализ, численная факторизация 
13 - Анализ, численная факторизация, решение, итеративное уточнение
22 - Численная факторизация
23 - Численная факторизация, решение, итеративное уточнение
33 - решение, итеративное уточнение
331 - как phase=33, но только прямая замена
332 - как phase=33, но только диагональная замена
333 - как phase=33, но только обратная замена
0 - Освободите внутреннюю память для последующего использования и введите номер матрицы mnum
-1 - Освободите всю внутреннюю память для всех матриц

const MKL_INT *n -
Число уравнений в разреженных линейных системах уравнений A*X=B

const void *a - массив
Содержит ненулевые элементы матрицы коэффициентов A, соответствующие индексам в ja. Матрица коэффициентов может быть как вещественной, так и комплексной. Матрица должна храниться в варианте с тремя массивами блочно-сжатой разреженной строки (CSR 3) или в варианте с тремя массивами блочно-сжатой разреженной строки (BSR3) формата, и матрица должна храниться с возрастающими значениями ja для каждой строки.

Для формата CSR 3 размер a такой же, как и у ja.

Для формата BSR 3 размер a равен размеру ja, умноженному на квадрат размера блока.

const MKL_INT *ia - массив(n+1).
Для формата CSR 3 ia[i] (i<n) указывает на индекс первого столбца строки i в массиве ja. То есть ia[i] дает индекс элемента в массиве a, который содержит первый ненулевой элемент из строки i из A. Последний элемент ia[n] принимается равным числу ненулевых элементов в A плюс один.

Для формата BSR 3 ia[i] (i<n) указывает на индекс первого столбца строки i в массиве ja. То есть, ia[i] дает индекс элемента в массиве a, который содержит первый ненулевой блок из строки i из A. Последний элемент ia[n] принимается равным количеству ненулевых блоков в A плюс один.

Доступ к массиву ia осуществляется на всех этапах процесса решения.

Индексация ia по умолчанию основана на единице, но ее можно изменить на нулевую, установив соответствующее значение параметру iparm[34]

const MKL_INT *ja -
Для формата CSR 3 массив ja содержит индексы столбцов разреженной матрицы A. Важно, чтобы индексы располагались в порядке возрастания в каждой строке. Для структурно симметричных матриц предполагается, что все диагональные элементы хранятся (даже если они являются нулями) в списке ненулевых элементов в a и ja.

Для формата BSR 3 массив ja содержит индексы столбцов разреженной матрицы A. Важно, чтобы индексы располагались в порядке возрастания в каждой строке. Для структурно симметричных матриц предполагается, что все диагональные блоки хранятся (даже если они являются нулями) в списке ненулевых блоков в a и ja. Для симметричных матриц решателю требуется только верхняя треугольная часть системы, как показано для массива столбцов в ...

Доступ к массиву осуществляется на всех этапах процесса решения.

Индексация ja по умолчанию основана на единице, но ее можно изменить на нулевую, установив соответствующее значение параметру iparm[34].


MKL_INT *perm - массив(n)
В зависимости от значения iparm[4] и iparm[35], содержит вектор перестановки размера n, определяет элементы, используемые для вычисления частичного решения, или задает различные значения входных матриц для обновления низкого ранга.

Если iparm[4]=1, iparm[30]=0 и iparm[35]=0, perm задает порядок заполнения, уменьшающий упорядоченность для решателя. Пусть A - исходная матрица, а C = P * A * P ^ T - переставленная матрица. Строка (столбец) i из C является постоянной [i] строкой (столбцом) A. Переменная массива также используется для возврата вектора перестановки, вычисленного на этапе заполнения и упорядочивания.

!!!Имейте в виду, что установка iparm[4]=1 предотвращает использование параллельного алгоритма для шага решения

* Если iparm[4]=2, iparm[30]=0 и iparm[35]=0, вектор перестановки, вычисленный на этапе 11, возвращается в массиве perm.

* Если iparm[4]=0, ipram[30] > 0 и iparm[35]=0, perm задает элементы правой части для использования или решения для вычисления частичного решения.

* Если iparm[4]=0, iparm[30] = 0 и iparm[35] > 0, perm задает элементы для дополнения Schur.

*Если iparm[38]=1, perm задает значения, которые отличаются в A для обновления низкого ранга. Размер массива должен быть не менее 2*different + 1, где n - количество различных значений A.
Значения perm должны быть:
Далее смотреть в учебнике

const MKL_INT *nrhs -
Количество правых частей, которые необходимо решить.

MKL_INT *iparm - массив(64)
Этот массив используется для передачи различных параметров в PARADISO и для возврата некоторой полезной информации после выполнения решателя.

const MKL_INT *msglvl -
Информация об уровне сообщения. Если msglvl=0, то pardiso не генерирует выходных данных, если msglevel = 1, решатель выводит статистическую информацию на экран.

void *b - массив(n*nrhs)
При вводе содержит вектор/матрицу B с правой стороны, которая помещается в память последовательно. Элемент b[+k*nrhs] должен содержать i-ю компоненту вектора правой стороны. Обратите внимание, что доступ к b возможен только на этапе решения.

void *x - массив(n*nrhs)
решение

MKL_INT *error -
Индикатор ошибки

Программа paradiso вычисляет решение набора разреженных линейных уравнений A*X=B с одной или несколькими правыми частями, используя параллельную факторизацию LU, LDL или LL^T, где A - матрица NxN, а X и B - векторы или матрицы nXnrhs.
































